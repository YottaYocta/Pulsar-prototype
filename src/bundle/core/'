
export const noteMappings = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];

export const chordTypes = {
  MAJOR7: 0,
  MINOR7: 1,
  DIMINISHED: 2,
  AUGMENTED: 3,
  DOMINANT: 4,
  MAJOR: 5,
  MINOR: 6
};

export const chordProgressions = {
  min1451: [
    {
      degree: 0,
      type: chordTypes.MINOR
    },
    {
      degree: 5,
      type: chordTypes.MINOR
    },
    {
      degree: 7,
      type: chordTypes.DOMINANT
    },
    {
      degree: 0,
      type: chordTypes.MINOR
    },
  ],
};

export function genRandomChordProgression() {
  let progressions = Object.values(chordProgressions);
  return progressions[Math.floor(Math.random() * progressions.length)];
}

export class Melody {
  constructor(numMeasures) {
    this.measures = [];
    this.octaveCenter = 5;
    for (let i = 0; i < numMeasures; i++) {
      this.measures.push(new Measure());
    }
  }

  genMelodyInKey(key) {
    let index = noteMappings.indexOf(key);
    let chordProgression = genRandomChordProgression();
    let count = 0;
    this.octaveCenter = Math.floor(Math.random() * 2) + 4;
    let octave = this.octaveCenter;
    for (let i = 0; i < this.measures.length; i++) {
      count = Math.floor(i / this.measures.length * chordProgression.length);
      let degree = (chordProgression[count].degree + index) % 12;
      console.log("degree", degree);
      octave = this.measures[i].genMeasure(degree, chordProgression[count], octave);
    }
  }

  getData() {
    let data = [];
    for (let i = 0; i < this.measures.length; i++) {
      let measureData = this.measures[i].getData();
      for (let j = 0; j < measureData.length; j++) {
        measureData[j].start += i * 16;
        data.push(measureData[j]);
      }
    }
    return data;
  }

  getDuration() {
    let duration = 0;
    for (let i = 0; i < this.measures.length; i++) {
      duration += 16;
    }
    return duration;
  }
}

export class Measure {
  constructor() {
    this.notes = [];
  }

  getData() {
    let data = [];
    for (let i = 0; i < this.notes.length; i++) {
      let absolute = this.notes[i].getAbsolute();
      let noteString = (absolute.degree == null) ? null : noteMappings[absolute.degree] + absolute.octave;
      let noteData = {
        note: noteString,
        duration: absolute.duration,
        start: absolute.start,
      }
      data.push(noteData);
    }
    return data;
  }

  genMeasure(scaleDegree, chord, octave) {
    let tonic = scaleDegree;
    let nOctave = octave;
    let values = genChordValues(chord);
    let degree = 0;
    let duration = 3;
    let weights = {
      up: 1,
      down: 1,
      repeat: 1,
      rest: 0
    }
    let totalWeightSum = weights.up + weights.down + weights.repeat;
    console.log("break");
    for (let i = 0; i < 4; i++) {
      degree++;
      degree %= values.length;
      let value = values[degree];
      let note = new Note(nOctave, value, tonic, duration, i * 4);
      console.log(nOctave, value, tonic);
      console.log(note.getAbsolute());
      this.notes.push(note);
      /**
      totalWeightSum = weights.up + weights.down + weights.repeat;
      let randomWeightSum = Math.random() * totalWeightSum;
      if (i == 1) {
        weights.repeat *= 5;
        weights.rest = Math.random();
      }
      if (i == 2) {
        weights.repeat /= 5;
        weights.rest = Math.random();
      }
      let value = (weights.rest > 0.3) ? null : values[degree];
      console.log(value);
      weights.rest = 0;
      this.notes.push(note);
      if (randomWeightSum > weights.repeat + weights.down) {
        degree++; 
        weights.up /= 5; 
        weights.down *= 5;
        if (degree > values.length - 1) {
          degree %= values.length;
          nOctave++;
        }
      }
      else if (randomWeightSum > weights.repeat) {
        degree--; 
        weights.down /= 5;
        weights.up *= 5;
        if (degree < 0) {
          degree = values.length + degree;
          nOctave--;
        }
      }
      else {
        weights.repeat /= 2;
      }
      **/
    }
    return nOctave;
  }
}

export class Note {
  constructor(octave, degree, tonic, duration, start) {
    this.octave = octave;
    this.degree = degree; 
    this.tonic = tonic;
    this.duration = duration;
    this.start = start;
  }

  getAbsolute() {
    let noteValue = (this.degree == null) ? null : (this.degree + 12 * this.octave) - this.tonic;
    console.log(noteValue + "abs");
    let absolute = {
      octave: Math.floor(noteValue / 12),
      degree: noteValue % 12,
      duration:  this.duration,
      start: this.start,
    };
    return absolute;
  }
}

export function parseSixteenthTime(count) {
  count = Math.floor(count);
  let measures = Math.floor(count / 16);
  count -= measures * 16;
  let quarters = Math.floor(count / 16);
  count -= quarters * 4;
  return measures + ":" + quarters + ":" + count;
}

export function genChordValues(chord) {
  let values;
  switch (chord.type) {
    case chordTypes.MAJOR7: values = [0, 4, 7, 11]; break;
    case chordTypes.MINOR7: values = [0, 3, 7, 10]; break;
    case chordTypes.DIMINISHED: values = [0, 3, 6, 9]; break;
    case chordTypes.AUGMENTED: values = [0, 4, 8, 10]; break;
    case chordTypes.DOMINANT: values = [0, 4, 7, 10]; break;
    case chordTypes.MAJOR: values = [0, 4, 7]; break;
    case chordTypes.MINOR: values = [0, 3, 7]; break;
  }
  return values;
}
